// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 1`] = `
"Incorrect

const promise = new Promise((resolve, reject) => resolve('value'));
promise;
~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(() => {});
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').catch();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

Promise.reject('value').finally();
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.

[1, 2, 3].map(async x => x + 1);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ An array of Promises may be unintentional. Consider handling the promises' fulfillment or rejection with Promise.all or similar, or explicitly marking the expression as ignored with the \`void\` operator.
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 2`] = `
"Correct

const promise = new Promise((resolve, reject) => resolve('value'));
await promise;

async function returnsPromise() {
  return 'value';
}
returnsPromise().then(
  () => {},
  () => {},
);

Promise.reject('value').catch(() => {});

await Promise.reject('value').finally(() => {});

await Promise.all([1, 2, 3].map(async x => x + 1));
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 3`] = `
"Options: { "ignoreVoid": true }

async function returnsPromise() {
  return 'value';
}
void returnsPromise();

void Promise.reject('value');
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 4`] = `
"Options: { "ignoreIIFE": true }

await (async function () {
  await res(1);
})();

(async function () {
  await res(1);
})();
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 5`] = `
"Incorrect
Options: {"allowForKnownSafePromises":[{"from":"file","name":"Foo"},{"from":"lib","name":"PromiseLike"},{"from":"package","name":"Bar","package":"bar-lib"}]}

type Foo = Promise<number> & { __linterBrands?: string }; // an example of a branded type
let Bazz = Promise.resolve(2);
Bazz;
~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
Bazz.then(() => {});
~~~~~~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
Bazz.catch();
~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
Bazz.finally();
~~~~~~~~~~~~~~~ Promises must be awaited, end with a call to .catch, end with a call to .then with a rejection handler or be explicitly marked as ignored with the \`void\` operator.
"
`;

exports[`Validating rule docs no-floating-promises.mdx code examples ESLint output 6`] = `
"Correct
Options: {"allowForKnownSafePromises":[{"from":"file","name":"Foo"},{"from":"file","name":"Shaw"},{"from":"lib","name":"PromiseLike"},{"from":"package","name":"Bar","package":"bar-lib"}]}

type Foo = Promise<number> & { __linterBrands?: string }; // an example of a branded type
let Bazz = Promise.resolve(2);
Bazz as Foo; // then apply the branded type as a type assertion
(Bazz as Foo).then(() => {});
(Bazz as Foo).catch();
(Bazz as Foo).finally();

// it also works in the form of type annotations
type Shaw = Promise<number> & { __linterBrands?: string }; // an example of a branded type
let Guzz: Shaw = Promise.resolve(2); // can be used as type annotation too
Guzz.then(() => {});
Guzz.catch();
Guzz.finally();
"
`;
